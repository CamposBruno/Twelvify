---
phase: 02-backend-integration-ai-simplification
plan: "02"
type: execute
wave: 2
depends_on:
  - "02-01"
files_modified:
  - src/messaging/messages.ts
  - src/storage/types.ts
  - src/entrypoints/content.ts
  - src/components/FloatingButton.tsx
  - wxt.config.ts
autonomous: true
requirements:
  - SIMP-02
  - BACK-04
  - ERRH-04

must_haves:
  truths:
    - "Clicking the Simplify button starts streaming simplification — text in the DOM is replaced word-by-word as SSE chunks arrive"
    - "Button shows spinner and is disabled during processing — concurrent requests are blocked"
    - "Text longer than 5000 characters triggers ERRH-04 error before any API call is made"
    - "Soft rate limit (50 req/hr) tracked client-side in chrome.storage — user sees warning before hitting backend hard limit"
    - "After successful simplification, button hides and page text is replaced seamlessly in-place"
    - "Scroll position does not jump during streaming text replacement"
  artifacts:
    - path: "src/messaging/messages.ts"
      provides: "SIMPLIFY_TEXT message type and error message types"
      contains: "SIMPLIFY_TEXT"
    - path: "src/storage/types.ts"
      provides: "ExtensionState with errorState field and simplifyCount for client-side rate limit"
      contains: "errorState"
    - path: "src/entrypoints/content.ts"
      provides: "handleSimplify() that calls backend SSE endpoint and replaces DOM text in-place"
      contains: "text/event-stream"
    - path: "src/components/FloatingButton.tsx"
      provides: "Spinner during loading, hides after simplification success"
      min_lines: 80
    - path: "wxt.config.ts"
      provides: "host_permissions updated to include real backend domain pattern"
  key_links:
    - from: "src/entrypoints/content.ts"
      to: "backend POST /api/simplify"
      via: "fetch with ReadableStream SSE parsing"
      pattern: "fetch.*simplify"
    - from: "src/entrypoints/content.ts"
      to: "chrome.storage.local"
      via: "SET_LOADING message + simplifyCount increment"
      pattern: "simplifyCount"
    - from: "src/components/FloatingButton.tsx"
      to: "src/storage/types.ts"
      via: "useStorageValue('isLoading') and useStorageValue('errorState')"
      pattern: "errorState"
---

<objective>
Wire the extension to the backend: replace the handleSimplify() stub with real SSE streaming, perform client-side text length validation, implement client-side soft rate limit tracking, and stream-replace DOM text in-place word-by-word.

Purpose: This is the core user-facing feature of Phase 2 — the moment a user clicks Simplify and watches their selected text transform in real-time. It covers SIMP-02 (AI simplification trigger), BACK-04 (HTTPS communication with validation), and ERRH-04 (text too long error).

Output: A fully wired extension → backend integration where clicking Simplify streams simplified text into the page, the button shows a spinner during processing, and the button hides after success.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-backend-integration-ai-simplification/02-CONTEXT.md
@.planning/phases/02-backend-integration-ai-simplification/02-RESEARCH.md
@.planning/phases/02-backend-integration-ai-simplification/02-01-SUMMARY.md
@src/messaging/messages.ts
@src/storage/types.ts
@src/entrypoints/content.ts
@src/components/FloatingButton.tsx
@wxt.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend message types, storage state, and update manifest host_permissions</name>
  <files>
    src/messaging/messages.ts
    src/storage/types.ts
    wxt.config.ts
  </files>
  <action>
    **src/messaging/messages.ts** — add new message types for Phase 2:

    Add to `MessageType` union:
    - `'SIMPLIFY_COMPLETE'` — background signals content script that simplification finished
    - `'SIMPLIFY_ERROR'` — background propagates error type and message to FloatingButton

    Add new interfaces:
    ```typescript
    export interface SimplifyCompleteMessage {
      type: 'SIMPLIFY_COMPLETE';
    }

    export interface SimplifyErrorMessage {
      type: 'SIMPLIFY_ERROR';
      errorCode: 'offline' | 'rate_limit' | 'timeout' | 'text_too_long' | 'ai_error' | 'unknown';
      message: string;        // Sarcastic user-facing message
      resetAt?: string;       // ISO string, only present for rate_limit errors
    }
    ```

    Update `ExtensionMessage` union to include `SimplifyCompleteMessage | SimplifyErrorMessage`.

    **src/storage/types.ts** — extend ExtensionState:

    Add fields to `ExtensionState` interface:
    ```typescript
    /** Current error state — null when no error. Drives error tooltip in FloatingButton */
    errorState: {
      code: 'offline' | 'rate_limit' | 'timeout' | 'text_too_long' | 'ai_error' | 'unknown';
      message: string;
      resetAt?: string;
    } | null;
    /** Client-side soft rate limit: requests in current hour window */
    simplifyCountThisHour: number;
    /** ISO timestamp when current hour window started */
    hourWindowStart: string | null;
    ```

    Update `DEFAULT_STATE`:
    ```typescript
    errorState: null,
    simplifyCountThisHour: 0,
    hourWindowStart: null,
    ```

    Keep existing fields: selectedText, selectedAt, isLoading, simplifyCount, lastSimplifiedAt.

    **wxt.config.ts** — update host_permissions:

    Change `'https://api.simplify.example.com/*'` to `'https://twelvify-backend.onrender.com/*'`.

    Also add a comment explaining this is the backend URL; executor should note in SUMMARY.md that this URL should be updated to match actual deployed backend URL before Chrome Web Store submission.

    Note: `connect-src` in content_security_policy also needs updating for the content script to fetch the backend. Add:
    ```typescript
    content_security_policy: {
      extension_pages: "script-src 'self'; object-src 'self';",
    }
    ```
    WXT generates content script CSP separately — the fetch from content scripts is governed by host_permissions, not extension_pages CSP.

    Verify: `npm run build` → exits 0, manifest in .output/chrome-mv3/manifest.json contains updated host_permissions.
  </action>
  <verify>
    1. npm run build → exits 0
    2. cat .output/chrome-mv3/manifest.json | grep "twelvify-backend" → present
    3. grep "errorState" src/storage/types.ts → present
    4. grep "SIMPLIFY_ERROR" src/messaging/messages.ts → present
  </verify>
  <done>
    messages.ts exports SimplifyErrorMessage and SimplifyCompleteMessage. types.ts has errorState and simplifyCountThisHour fields in ExtensionState and DEFAULT_STATE. wxt.config.ts has updated host_permissions. npm run build passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement handleSimplify() with SSE streaming, client-side rate limit, and in-place DOM replacement</name>
  <files>
    src/entrypoints/content.ts
    src/components/FloatingButton.tsx
  </files>
  <action>
    **src/entrypoints/content.ts** — replace the Phase 1 stub handleSimplify() with the full implementation:

    The new handleSimplify() function must:

    1. **Client-side soft rate limit check (50 req/hr)**:
    ```typescript
    // Read simplifyCountThisHour and hourWindowStart from storage
    // If hourWindowStart is null or > 1 hour ago, reset: { simplifyCountThisHour: 0, hourWindowStart: now }
    // If simplifyCountThisHour >= 50, send SIMPLIFY_ERROR with code 'rate_limit' and message:
    // "Easy there, speed racer. You've hit your hourly limit. Try again in X minutes."
    // (calculate minutes from hourWindowStart + 3600000 - Date.now())
    // Return early — do not call backend
    ```

    2. **Text length check (>5000 chars)**:
    ```typescript
    // Read selectedText from storage
    // If selectedText.length > 5000, send SIMPLIFY_ERROR with code 'text_too_long':
    // message: "Easy there, speed racer. That's too much to chew. Select a shorter passage (under 5000 characters)."
    // Return early
    ```

    3. **Offline check**:
    ```typescript
    if (!navigator.onLine) {
      // send SIMPLIFY_ERROR with code 'offline':
      // message: "Wow, no internet. Shocking."
      return;
    }
    ```

    4. **Capture the DOM range before any async work**:
    Before calling the backend, capture the current Selection's Range object. This is critical — the user may click away during streaming.
    ```typescript
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0) return;
    const range = selection.getRangeAt(0).cloneRange();
    // Save scroll position to restore after replacement
    const scrollX = window.scrollX;
    const scrollY = window.scrollY;
    ```

    5. **Set loading state**:
    ```typescript
    chrome.runtime.sendMessage({ type: 'SET_LOADING', isLoading: true } as ExtensionMessage);
    ```

    6. **Fetch with SSE streaming**:
    Use the Fetch API with ReadableStream (NOT EventSource — EventSource doesn't support POST with body).
    ```typescript
    const BACKEND_URL = 'https://twelvify-backend.onrender.com/api/simplify';
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 10000);

    try {
      const response = await fetch(BACKEND_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text: selectedText }),
        signal: controller.signal,
      });
      clearTimeout(timeoutId);

      if (response.status === 429) {
        const data = await response.json();
        // Send rate limit error — use resetAt from response to show exact time
        const resetAt = data.resetAt ? new Date(data.resetAt) : new Date(Date.now() + 3600000);
        const minutesLeft = Math.ceil((resetAt.getTime() - Date.now()) / 60000);
        chrome.runtime.sendMessage({
          type: 'SIMPLIFY_ERROR',
          errorCode: 'rate_limit',
          message: `Chill, I need a break. Try again in ${minutesLeft} minute${minutesLeft === 1 ? '' : 's'}.`,
          resetAt: resetAt.toISOString(),
        } as ExtensionMessage);
        chrome.runtime.sendMessage({ type: 'SET_LOADING', isLoading: false } as ExtensionMessage);
        return;
      }

      if (!response.ok) {
        // Handle 400 text_too_long from backend (belt-and-suspenders; client already checks)
        const data = await response.json().catch(() => ({}));
        chrome.runtime.sendMessage({
          type: 'SIMPLIFY_ERROR',
          errorCode: (data.error === 'text_too_long') ? 'text_too_long' : 'ai_error',
          message: data.message ?? 'Something broke. Try again?',
        } as ExtensionMessage);
        chrome.runtime.sendMessage({ type: 'SET_LOADING', isLoading: false } as ExtensionMessage);
        return;
      }

      // 7. Stream SSE chunks — parse line by line
      const reader = response.body!.getReader();
      const decoder = new TextDecoder();
      let accumulated = '';
      let buffer = '';

      // Delete the original selected text immediately and create a text node placeholder
      range.deleteContents();
      const textNode = document.createTextNode('');
      range.insertNode(textNode);
      window.scrollTo(scrollX, scrollY);  // Restore scroll position

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split('\n');
        buffer = lines.pop() ?? '';  // Keep incomplete line in buffer

        for (const line of lines) {
          if (!line.startsWith('data: ')) continue;
          try {
            const payload = JSON.parse(line.slice(6));
            if (payload.error) {
              // Stream-level error (timeout, ai_error)
              chrome.runtime.sendMessage({
                type: 'SIMPLIFY_ERROR',
                errorCode: payload.error === 'timeout' ? 'timeout' : 'ai_error',
                message: payload.message ?? 'Something broke. Try again?',
              } as ExtensionMessage);
              chrome.runtime.sendMessage({ type: 'SET_LOADING', isLoading: false } as ExtensionMessage);
              return;
            }
            if (payload.chunk) {
              accumulated += payload.chunk;
              textNode.textContent = accumulated;  // Update DOM in-place
            }
            if (payload.done) {
              // Simplification complete — update rate limit count, clear loading, trigger fade
              chrome.storage.local.get(['simplifyCount', 'simplifyCountThisHour', 'hourWindowStart'], (result) => {
                chrome.storage.local.set({
                  isLoading: false,
                  selectedText: '',           // Hide button — user can select again
                  simplifyCount: (result.simplifyCount ?? 0) + 1,
                  simplifyCountThisHour: (result.simplifyCountThisHour ?? 0) + 1,
                  errorState: null,           // Clear any prior error
                  lastSimplifiedAt: Date.now(),
                });
              });
              // Trigger brief highlight + fade (CSS class on the text node's parent)
              // Use a span wrapper for the highlight animation
              const span = document.createElement('span');
              span.setAttribute('data-twelvify-simplified', 'true');
              span.style.cssText = 'background: rgba(99, 102, 241, 0.2); border-radius: 3px; transition: background 1.5s ease;';
              textNode.parentNode?.insertBefore(span, textNode);
              span.appendChild(textNode);
              setTimeout(() => {
                span.style.background = 'transparent';
                setTimeout(() => {
                  // Unwrap span — restore plain text node in DOM
                  const parent = span.parentNode;
                  if (parent) {
                    while (span.firstChild) parent.insertBefore(span.firstChild, span);
                    parent.removeChild(span);
                  }
                }, 1600);
              }, 100);
            }
          } catch {
            // Malformed SSE line — skip silently
          }
        }
      }
    } catch (err: unknown) {
      clearTimeout(timeoutId);
      const error = err as Error;
      const isAbort = error.name === 'AbortError';
      chrome.runtime.sendMessage({
        type: 'SIMPLIFY_ERROR',
        errorCode: isAbort ? 'timeout' : 'offline',
        message: isAbort
          ? "That took too long. Hit me again?"
          : "Wow, no internet. Shocking.",
      } as ExtensionMessage);
      chrome.runtime.sendMessage({ type: 'SET_LOADING', isLoading: false } as ExtensionMessage);
    }
    ```

    IMPORTANT: The handleSimplify function must be declared as `async function handleSimplify()` and called with `handleSimplify()` (not awaited — fire-and-forget from the onClick). Keep the `onSimplify` prop passing pattern.

    Also update the background.ts message handler to handle `SIMPLIFY_ERROR` and `SIMPLIFY_COMPLETE` — these need to persist errorState to storage:

    In `src/entrypoints/background.ts`, add cases:
    ```typescript
    case 'SIMPLIFY_ERROR':
      chrome.storage.local.set({
        isLoading: false,
        errorState: {
          code: message.errorCode,
          message: message.message,
          ...(message.resetAt ? { resetAt: message.resetAt } : {}),
        },
      }, () => sendResponse({ status: 'received' }));
      break;

    case 'SIMPLIFY_COMPLETE':
      chrome.storage.local.set(
        { isLoading: false, errorState: null },
        () => sendResponse({ status: 'received' })
      );
      break;
    ```

    Note: Background.ts must also be in files_modified. Add it to the task.

    **src/components/FloatingButton.tsx** — extend to read errorState:

    Add `useStorageValue<ExtensionState['errorState']>('errorState', null)` to read error state.

    Add auto-dismiss logic: when errorState becomes non-null, set a 5-second timeout to clear it via chrome.storage.local.set({ errorState: null }).

    The button should hide (clear selectedText) after successful simplification — this is already handled in content.ts by setting selectedText: '' in storage, so FloatingButton automatically becomes invisible.

    No visual error state needed yet (Plan 03 handles the yellow/shake/tooltip UI). FloatingButton just needs to read errorState for Plan 03 to extend. Add the hook read now; visual treatment comes next plan.

    Verify: npm run build exits 0.
  </action>
  <verify>
    1. npm run build → exits 0
    2. grep "text/event-stream\|ReadableStream\|getReader" src/entrypoints/content.ts → present (SSE via fetch)
    3. grep "simplifyCountThisHour" src/entrypoints/content.ts → present (client-side rate limit)
    4. grep "5000\|text_too_long" src/entrypoints/content.ts → present (length check)
    5. grep "navigator.onLine" src/entrypoints/content.ts → present (offline check)
    6. grep "deleteContents\|createTextNode" src/entrypoints/content.ts → present (DOM replacement)
    7. grep "errorState" src/components/FloatingButton.tsx → present (hook read)
  </verify>
  <done>
    content.ts handleSimplify() is async, calls backend via fetch+ReadableStream SSE, replaces DOM text in-place via Range.deleteContents() + textNode.textContent updates, handles all error cases (offline, rate limit, timeout, text too long), increments simplifyCountThisHour in storage. FloatingButton reads errorState. npm run build passes. background.ts handles SIMPLIFY_ERROR.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. npm run build → exits 0
2. cat .output/chrome-mv3/manifest.json | grep host_permissions → shows backend domain
3. grep "errorState" src/storage/types.ts src/components/FloatingButton.tsx src/entrypoints/content.ts → all 3 files contain it
4. grep "simplifyCountThisHour" src/entrypoints/content.ts → client-side rate limit implemented
5. grep "deleteContents\|textContent" src/entrypoints/content.ts → in-place DOM streaming replacement present
6. Manually test (or note for Plan 04 checkpoint): load extension, select text, click Simplify — spinner appears and text replaces in-place
</verification>

<success_criteria>
- Extension calls backend POST /api/simplify via fetch with ReadableStream SSE parsing (BACK-04, SIMP-02)
- DOM text replaced in-place word-by-word as chunks arrive (SIMP-02 streaming)
- Text >5000 chars triggers client-side error before API call (ERRH-04)
- Client-side soft rate limit (50/hr) tracked in chrome.storage (BACK-02 soft layer)
- Button disabled + spinner during processing, hides after success (SIMP-02 UX)
- Brief highlight + fade after successful simplification (per CONTEXT.md locked decision)
- npm run build passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/02-backend-integration-ai-simplification/02-02-SUMMARY.md`
</output>
