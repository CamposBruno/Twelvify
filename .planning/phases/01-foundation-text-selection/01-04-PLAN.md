---
phase: 01-foundation-text-selection
plan: "04"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/FloatingButton.tsx
  - src/entrypoints/content.ts
autonomous: false
requirements:
  - SIMP-01
  - EXTF-03
gap_closure: true

must_haves:
  truths:
    - "User sees the Simplify button within 200ms of selecting 10+ characters on any webpage"
    - "User sees the Simplify button disappear after deselecting or clicking away"
    - "User can click Simplify and see a loading spinner for ~1 second"
    - "Button works on regular page text, textareas, and input fields"
  artifacts:
    - path: "src/components/FloatingButton.tsx"
      provides: "Always-rendered button whose visibility is driven by selectedText in storage"
      contains: "always rendered — no conditional null return based on selectedText"
    - path: "src/entrypoints/content.ts"
      provides: "Simplified content script with no showPopover/hidePopover calls"
      contains: "no showPopover, no hidePopover, no Popover API"
  key_links:
    - from: "src/entrypoints/content.ts"
      to: "chrome.storage.local"
      via: "sendMessage -> background -> storage write"
      pattern: "TEXT_SELECTED|CLEAR_SELECTION"
    - from: "src/components/FloatingButton.tsx"
      to: "chrome.storage.local"
      via: "useStorageValue('selectedText')"
      pattern: "useStorageValue.*selectedText"
---

<objective>
Fix the race condition that prevents the Simplify button from appearing.

Purpose: Phase 1 has one failing UAT test — the core user-facing feature (button appears on text selection) never worked because of an architectural race condition between Popover API imperative calls and React's async render cycle.

Output: A FloatingButton component that always renders its DOM element and controls visibility purely through React state, removing the entire two-channel race condition. The Popover API is replaced with simple CSS visibility driven by selectedText from storage.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-text-selection/01-UAT.md
@.planning/debug/button-not-showing.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor FloatingButton to always render and use CSS visibility</name>
  <files>src/components/FloatingButton.tsx</files>
  <action>
    Remove the Popover API entirely. The root cause is that FloatingButton returns null when selectedText is falsy, so the DOM element #twelvify-floating-btn does not exist when showPopover() fires from content.ts.

    Fix: always render the button element. Control visibility with a CSS property (display: none vs display: block, or opacity + pointer-events) driven directly by the selectedText value from useStorageValue.

    Specific changes:
    1. Keep both useStorageValue calls: isLoading (boolean) and selectedText (string).
    2. Remove the `if (!selectedText) return null` block (lines 26-28) — this is the conditional render that causes the race.
    3. Remove the `popover="manual"` attribute from the outer div and remove all popover-related inline styles (position: fixed, bottom, right, border, padding, background, margin were all for the popover container).
    4. Replace the outer div with a styled container div that:
       - Is always present in the DOM
       - Is positioned fixed, bottom: 24px, right: 24px
       - Has visibility: hidden and pointerEvents: none when !selectedText
       - Has visibility: visible and pointerEvents: auto when selectedText is truthy
       - Uses a transition: opacity 0.15s ease for smooth show/hide
       - Sets opacity: 0 when hidden, opacity: 1 when visible
    5. Remove the `declare module 'react'` block that extended HTMLAttributes with popover props — no longer needed.
    6. Keep all button styling exactly as-is (backgroundColor, color, border, borderRadius, fontSize, fontWeight, cursor, boxShadow, fontFamily, opacity for loading).
    7. Keep the loading spinner SVG, the spark icon SVG, and the @keyframes twelvify-spin style block — they are correct and unrelated to the bug.
    8. The button element's onClick and disabled props remain unchanged.

    Result: React always has a DOM element in place. Visibility flips the instant useStorageValue receives the storage change — no imperative showPopover() call ever needed.
  </action>
  <verify>
    1. `npm run build` exits cleanly with no TypeScript or JSX errors.
    2. The compiled output at `.output/chrome-mv3/content-scripts/content.js` does NOT contain the string "showPopover" (confirms popover API removed from component).
    3. The compiled content.js DOES contain "twelvify-floating-btn" (confirms the element id is still present for any future reference).
    4. Grep src/components/FloatingButton.tsx — confirm NO `if (!selectedText) return null` line exists.
    5. Grep src/components/FloatingButton.tsx — confirm NO `popover=` attribute exists.
  </verify>
  <done>
    FloatingButton always renders an element in the DOM. When selectedText is falsy, the element is invisible (opacity 0, pointerEvents none). When selectedText is truthy, the element is visible. No Popover API attributes remain.
  </done>
</task>

<task type="auto">
  <name>Task 2: Remove showPopover/hidePopover from content script</name>
  <files>src/entrypoints/content.ts</files>
  <action>
    The showPopover() and hidePopover() helper functions in content.ts are now dead code — FloatingButton manages its own visibility via React state. Remove them and simplify the message handling.

    Specific changes:
    1. Delete the showPopover() function (lines 34-39).
    2. Delete the hidePopover() function (lines 41-46).
    3. In handleSelectionChange(), remove the showPopover() call from the chrome.runtime.sendMessage callback (line 74). The callback can simply be simplified — the message still needs to be sent to write selectedText to storage, but the response callback no longer needs to call showPopover. You can simplify the callback to just handle chrome.runtime.lastError (retry on service worker restart):
       ```ts
       chrome.runtime.sendMessage(message, (response) => {
         if (chrome.runtime.lastError) {
           chrome.runtime.sendMessage(message);
         }
         // No showPopover() needed — FloatingButton reads from storage directly
       });
       ```
    4. Remove the hidePopover() call from the else branch in handleSelectionChange() (line 81). The CLEAR_SELECTION message still needs to be sent so background writes selectedText: '' to storage, which React will pick up.
    5. Remove the hidePopover() call from the click outside handler (line 119). The CLEAR_SELECTION message send remains.
    6. Verify no remaining references to showPopover or hidePopover exist in the file.

    The content script now has a single responsibility: detect selection events and send messages to background. FloatingButton is fully self-contained for visibility.
  </action>
  <verify>
    1. `npm run build` exits cleanly.
    2. `grep -n "showPopover\|hidePopover" src/entrypoints/content.ts` returns no matches.
    3. `grep -n "sendMessage" src/entrypoints/content.ts` still shows TEXT_SELECTED and CLEAR_SELECTION sends (confirms message passing preserved).
    4. The compiled `.output/chrome-mv3/content-scripts/content.js` does NOT contain "showPopover" anywhere.
  </verify>
  <done>
    content.ts has no showPopover or hidePopover functions or calls. The file only handles selection detection and message dispatch. npm run build is clean.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify button appears on text selection</name>
  <action>Human verifies the fix works end-to-end in Chrome after reloading the extension.</action>
  <what-built>
    Refactored FloatingButton to always render (CSS visibility, no Popover API) and removed showPopover/hidePopover from content.ts. The race condition is eliminated — visibility is now controlled entirely by React reading selectedText from chrome.storage.
  </what-built>
  <how-to-verify>
    1. Run `npm run build` and confirm it exits cleanly.
    2. In Chrome, go to chrome://extensions — click the reload button on the Twelveify extension (or toggle off/on).
    3. Navigate to any webpage (a news article, Wikipedia, etc.).
    4. Select 10 or more characters of text by clicking and dragging.
    5. Expected: A purple "Simplify" button appears in the bottom-right corner of the viewport within ~200ms.
    6. Click anywhere outside the selected text.
    7. Expected: The Simplify button disappears (or fades out).
    8. Re-select text, then click the Simplify button.
    9. Expected: Button shows "Simplifying..." with a spinner for ~1 second, then returns to normal.
    10. Try selecting text inside a textarea or input field on any page.
    11. Expected: Button appears for textarea/input selections too.
  </how-to-verify>
  <verify>Human confirms all steps above pass.</verify>
  <done>All 4 UAT tests (3, 4, 5, 6) pass. Button appears on selection, disappears on deselect, shows spinner on click, works in textareas.</done>
  <resume-signal>Type "approved" if all steps pass. Describe any issues if steps fail.</resume-signal>
</task>

</tasks>

<verification>
Build verification (automated):
- `npm run build` exits with code 0
- No TypeScript errors
- No "showPopover" in compiled content.js
- FloatingButton.tsx has no `return null` conditional based on selectedText

Manual verification:
- Button appears within ~200ms on text selection
- Button disappears on deselect / click away
- Loading spinner shows on click
- Works in textareas and input fields
</verification>

<success_criteria>
UAT Test 3 passes: Selecting 10+ characters on any webpage causes the Simplify button to appear near the bottom-right of the viewport within ~200ms.

Secondary tests unblocked by Test 3:
- Test 4: Deselecting hides the button
- Test 5: Clicking Simplify shows loading spinner for ~1 second
- Test 6: Button appears for textarea/input selections
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-text-selection/01-04-SUMMARY.md` following the template at `.claude/get-shit-done/templates/summary.md`.
</output>
