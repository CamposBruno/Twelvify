---
phase: 01-foundation-text-selection
plan: 02
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - src/entrypoints/background.ts
  - src/storage/types.ts
  - src/storage/useStorage.ts
  - src/messaging/messages.ts
autonomous: true
requirements:
  - EXTF-02

must_haves:
  truths:
    - "Service worker registers event listeners at top level (not inside async callbacks)"
    - "All application state reads and writes use chrome.storage.local — zero module-scope global variables"
    - "Service worker correctly receives TEXT_SELECTED messages from content scripts"
    - "Service worker persists selectedText, isLoading state to chrome.storage.local"
    - "After chrome.storage.local.set, state survives a service worker restart"
  artifacts:
    - path: "src/entrypoints/background.ts"
      provides: "Service worker entry point with top-level message listener"
      contains: "chrome.runtime.onMessage.addListener"
    - path: "src/storage/types.ts"
      provides: "TypeScript interfaces for all chrome.storage state"
      contains: "ExtensionState"
    - path: "src/storage/useStorage.ts"
      provides: "React hook for reading/writing chrome.storage in React components"
      contains: "useStorageValue"
    - path: "src/messaging/messages.ts"
      provides: "Type-safe message definitions for content-to-background communication"
      contains: "TEXT_SELECTED"
  key_links:
    - from: "src/entrypoints/background.ts"
      to: "chrome.storage.local"
      via: "chrome.storage.local.set() on message receive"
      pattern: "chrome\\.storage\\.local\\.set"
    - from: "src/messaging/messages.ts"
      to: "src/entrypoints/background.ts"
      via: "message type imports"
      pattern: "MESSAGE_TYPE"
---

<objective>
Implement the service worker (background.ts) with correct MV3 state persistence patterns, and establish the shared type system for storage and messaging. This is the state management backbone — all state goes through chrome.storage.local, never global variables.

Purpose: Service workers terminate after 30 seconds of inactivity; global state is lost. This plan enforces the correct pattern that prevents broken state across all Phase 1+ features.
Output: Working background.ts with top-level listeners, chrome.storage state persistence, shared message types and storage hooks.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-text-selection/01-RESEARCH.md
@.planning/phases/01-foundation-text-selection/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared types and message definitions</name>
  <files>
    src/storage/types.ts
    src/messaging/messages.ts
  </files>
  <action>
    Create src/storage/types.ts with the ExtensionState interface representing all data stored in chrome.storage.local:

    ```typescript
    // src/storage/types.ts
    // All chrome.storage.local state for Twelveify

    export interface ExtensionState {
      /** Text the user has selected for simplification */
      selectedText: string;
      /** ISO timestamp when text was selected */
      selectedAt: number | null;
      /** Whether the AI is currently processing a simplification request */
      isLoading: boolean;
      /** Number of simplifications performed (for rate limiting in Phase 2) */
      simplifyCount: number;
      /** ISO timestamp of last simplification (for rate limiting in Phase 2) */
      lastSimplifiedAt: number | null;
    }

    export const DEFAULT_STATE: ExtensionState = {
      selectedText: '',
      selectedAt: null,
      isLoading: false,
      simplifyCount: 0,
      lastSimplifiedAt: null,
    };
    ```

    Create src/messaging/messages.ts with type-safe message definitions:

    ```typescript
    // src/messaging/messages.ts
    // Type-safe message contracts between content scripts and service worker

    export type MessageType = 'TEXT_SELECTED' | 'CLEAR_SELECTION' | 'SET_LOADING';

    export interface TextSelectedMessage {
      type: 'TEXT_SELECTED';
      text: string;
      timestamp: number;
    }

    export interface ClearSelectionMessage {
      type: 'CLEAR_SELECTION';
    }

    export interface SetLoadingMessage {
      type: 'SET_LOADING';
      isLoading: boolean;
    }

    export type ExtensionMessage =
      | TextSelectedMessage
      | ClearSelectionMessage
      | SetLoadingMessage;

    export interface MessageResponse {
      status: 'received' | 'error';
      error?: string;
    }
    ```
  </action>
  <verify>
    Run `npm run build` from /Users/brunocampos/Twelvify — TypeScript must compile both files without errors. Check that types are exported correctly.
  </verify>
  <done>
    src/storage/types.ts and src/messaging/messages.ts exist with zero TypeScript errors. ExtensionState interface exported with all 5 fields. ExtensionMessage union type exported covering TEXT_SELECTED, CLEAR_SELECTION, SET_LOADING.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement service worker with top-level listeners and chrome.storage persistence</name>
  <files>
    src/entrypoints/background.ts
    src/storage/useStorage.ts
  </files>
  <action>
    Create src/entrypoints/background.ts as the MV3 service worker entry point:

    ```typescript
    // src/entrypoints/background.ts
    // MV3 Service Worker — state manager and message router
    // CRITICAL: All listeners at TOP LEVEL — never inside async functions

    import type { ExtensionMessage, MessageResponse } from '../messaging/messages';
    import type { ExtensionState } from '../storage/types';
    import { DEFAULT_STATE } from '../storage/types';

    export default defineBackground(() => {
      // CRITICAL: Register listener at top level (not inside async callback)
      // Listeners registered inside async/promise callbacks are not guaranteed to fire
      chrome.runtime.onMessage.addListener(
        (message: ExtensionMessage, _sender, sendResponse: (response: MessageResponse) => void) => {
          handleMessage(message, sendResponse);
          // Return true to indicate async response
          return true;
        }
      );

      // Initialize storage with defaults on first install
      chrome.runtime.onInstalled.addListener(({ reason }) => {
        if (reason === 'install') {
          chrome.storage.local.set(DEFAULT_STATE);
        }
      });
    });

    function handleMessage(
      message: ExtensionMessage,
      sendResponse: (response: MessageResponse) => void
    ): void {
      switch (message.type) {
        case 'TEXT_SELECTED':
          // Persist selection to storage — never use global variable
          chrome.storage.local.set(
            {
              selectedText: message.text,
              selectedAt: message.timestamp,
              isLoading: false,
            },
            () => {
              if (chrome.runtime.lastError) {
                sendResponse({ status: 'error', error: chrome.runtime.lastError.message });
              } else {
                sendResponse({ status: 'received' });
              }
            }
          );
          break;

        case 'CLEAR_SELECTION':
          chrome.storage.local.set(
            { selectedText: '', selectedAt: null, isLoading: false },
            () => sendResponse({ status: 'received' })
          );
          break;

        case 'SET_LOADING':
          chrome.storage.local.set(
            { isLoading: message.isLoading },
            () => sendResponse({ status: 'received' })
          );
          break;

        default:
          sendResponse({ status: 'error', error: 'Unknown message type' });
      }
    }
    ```

    Create src/storage/useStorage.ts with a React hook for chrome.storage access in UI components:

    ```typescript
    // src/storage/useStorage.ts
    // React hook for reading/writing chrome.storage.local in UI components

    import { useState, useEffect } from 'react';

    export function useStorageValue<T>(
      key: string,
      defaultValue: T
    ): [T, (value: T) => Promise<void>] {
      const [value, setValue] = useState<T>(defaultValue);

      useEffect(() => {
        // Read initial value
        chrome.storage.local.get([key], (result) => {
          if (result[key] !== undefined) {
            setValue(result[key] as T);
          }
        });

        // Listen for changes from background script
        const listener = (changes: { [key: string]: chrome.storage.StorageChange }) => {
          if (changes[key] !== undefined) {
            setValue(changes[key].newValue as T);
          }
        };

        chrome.storage.onChanged.addListener(listener);
        return () => chrome.storage.onChanged.removeListener(listener);
      }, [key]);

      const updateValue = async (newValue: T): Promise<void> => {
        setValue(newValue);
        await chrome.storage.local.set({ [key]: newValue });
      };

      return [value, updateValue];
    }
    ```

    Verify that NO module-scope variables store application state in background.ts. The only module-scope code is the defineBackground() call and the handleMessage function definition.
  </action>
  <verify>
    1. Run `npm run build` — exits 0 with no TypeScript errors
    2. Grep for global variable anti-patterns: `grep -n "^let\|^var\|^const [a-z]" /Users/brunocampos/Twelvify/src/entrypoints/background.ts` — should return nothing (no module-scope mutable state)
    3. Grep for top-level listener: `grep -n "onMessage.addListener" /Users/brunocampos/Twelvify/src/entrypoints/background.ts` — should be inside defineBackground() but NOT inside an async function
    4. Grep for chrome.storage usage: `grep -n "chrome.storage" /Users/brunocampos/Twelvify/src/entrypoints/background.ts` — should show set() calls in handleMessage
  </verify>
  <done>
    background.ts compiles without errors, has zero module-scope state variables, registers onMessage listener at top level inside defineBackground(), all state mutations use chrome.storage.local.set(). useStorage.ts exports useStorageValue hook that reads from and listens to chrome.storage.local changes.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` exits 0 after adding background.ts entrypoint
2. `.output/chrome-mv3/manifest.json` includes background.service_worker pointing to built background script
3. No module-scope mutable state variables in background.ts
4. onMessage listener registered at defineBackground() top level
5. All 3 message types handled (TEXT_SELECTED, CLEAR_SELECTION, SET_LOADING)
6. chrome.storage.local.set() called in every message handler
</verification>

<success_criteria>
- Service worker builds and is included in extension output
- All state persists via chrome.storage.local — zero global variables
- Message types fully typed with TypeScript union type
- useStorageValue hook available for React components in Plans 03+
- Pattern enforces "treat service worker as stateless" architecture
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-text-selection/01-02-SUMMARY.md`
</output>
