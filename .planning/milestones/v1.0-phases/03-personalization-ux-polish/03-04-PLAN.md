---
phase: 03-personalization-ux-polish
plan: 04
type: execute
wave: 3
depends_on: [03-01, 03-02, 03-03]
files_modified:
  - src/entrypoints/content.ts
autonomous: true
requirements: [SIMP-03, SIMP-04, DISP-01, DISP-02, PERS-01, PERS-02, PERS-03]

must_haves:
  truths:
    - "Content script reads tone/depth/profession from chrome.storage.sync and passes them in the fetch request body"
    - "After simplification, original text pushed to undo stack; FloatingButton receives hasUndo=true"
    - "ESC key reverts most recent simplification in reverse order (stack-based)"
    - "SIMPLIFY_HOTKEY message triggers handleSimplify() only when text is selected"
    - "Display mode checked from chrome.storage.sync before rendering: popup mode renders FloatingPopup, replace mode uses existing in-place streaming"
    - "Undo stack clears on page navigation (beforeunload)"
    - "After 3rd simplification, onboarding prompt appears inline below simplified text"
    - "Dismissed onboarding prompts never reappear"
  artifacts:
    - path: "src/entrypoints/content.ts"
      provides: "Full Phase 3 content script with personalization, undo, hotkey, display mode"
      contains: "SIMPLIFY_HOTKEY"
  key_links:
    - from: "src/entrypoints/content.ts"
      to: "backend /api/simplify"
      via: "fetch with tone/depth/profession in request body"
      pattern: "tone.*depth.*profession"
    - from: "src/entrypoints/content.ts"
      to: "UndoStack"
      via: "undoStack.push() after SSE done, undoStack.revertLast() on ESC or undo click"
      pattern: "undoStack\\.push"
    - from: "src/entrypoints/content.ts"
      to: "FloatingButton"
      via: "renderButton() called with hasUndo/onUndo props after each simplification"
      pattern: "hasUndo"
    - from: "src/entrypoints/content.ts"
      to: "OnboardingPrompt"
      via: "getNextOnboardingPrompt() called after payload.done; renders OnboardingPrompt below simplified span"
      pattern: "getNextOnboardingPrompt"
---

<objective>
Upgrade content.ts to orchestrate all Phase 3 interactive features: personalization parameters, undo stack integration, keyboard shortcut handling, and display mode routing.

Purpose: content.ts is the runtime hub of the extension — it runs in the page, owns the DOM, drives the floating button, and executes simplification. All Phase 3 behavior (passing user preferences to backend, tracking undo history, responding to keyboard hotkey, routing to popup display mode) converges here.

Output: Updated content.ts that reads settings from chrome.storage.sync, passes tone/depth/profession to backend, maintains undo stack, handles ESC key and SIMPLIFY_HOTKEY message, routes to FloatingPopup when displayMode='popup', and re-renders FloatingButton with hasUndo state.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@src/entrypoints/content.ts
@src/utils/undoStack.ts
@src/components/FloatingButton.tsx
@src/storage/types.ts
@src/storage/useStorage.ts
@src/messaging/messages.ts
@.planning/phases/03-personalization-ux-polish/03-01-SUMMARY.md
@.planning/phases/03-personalization-ux-polish/03-02-SUMMARY.md
@.planning/phases/03-personalization-ux-polish/03-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add personalization reads, undo stack, hotkey handler, and display mode routing to content.ts</name>
  <files>src/entrypoints/content.ts</files>
  <action>
Refactor `src/entrypoints/content.ts` with the following changes. Preserve ALL existing logic (preflight checks, SSE streaming, error handling, scroll restoration, highlight fade, rate limiting). Do not break any Phase 2 behavior.

**1. New imports at top:**
```typescript
import { UndoStack } from '../utils/undoStack';
import { FloatingPopup } from '../components/FloatingPopup';
import type { ToneLevel } from '../storage/types';
import { DEFAULT_SETTINGS } from '../storage/types';
```

**2. Module-level undo stack (above `main()`):**
```typescript
const undoStack = new UndoStack();
```

**3. Inside `main()`, update `renderButton()` to pass undo props:**
```typescript
function renderButton() {
  root.render(
    createElement(FloatingButton, {
      onSimplify: handleSimplify,
      onUndo: handleUndo,
      hasUndo: !undoStack.isEmpty(),
    })
  );
}
```

Call `renderButton()` whenever undo state changes (after push, after revert).

**4. Add `handleUndo()` function inside `main()`:**
```typescript
function handleUndo() {
  undoStack.revertLast();
  renderButton(); // Re-render to update hasUndo state
}
```

**5. ESC key listener (register at top level of `main()`, not inside async):**
```typescript
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && !undoStack.isEmpty()) {
    e.preventDefault();
    handleUndo();
  }
});
```

**6. Clear undo stack on page navigation:**
```typescript
window.addEventListener('beforeunload', () => {
  undoStack.clear();
  renderButton();
});
```

**7. SIMPLIFY_HOTKEY message listener (at top level of `main()`):**
```typescript
chrome.runtime.onMessage.addListener((message) => {
  if (message.type === 'SIMPLIFY_HOTKEY') {
    const sel = window.getSelection();
    if (sel && sel.toString().trim().length > 3) {
      handleSimplify();
    }
    // Silent no-op if no text selected (CONTEXT.md: "only works with text selected")
  }
});
```

**8. Read personalization settings before fetch in `handleSimplify()`:**

At the start of `handleSimplify()`, after reading the existing state (simplifyCountThisHour, etc.), also read user settings from chrome.storage.sync:

```typescript
const settings = await new Promise<{ tone: ToneLevel; depth: string; profession: string; displayMode: string }>((resolve) => {
  chrome.storage.sync.get(
    ['tone', 'depth', 'profession', 'displayMode'],
    (result) => resolve({
      tone: (result.tone as ToneLevel) ?? DEFAULT_SETTINGS.tone,
      depth: (result.depth as string) ?? DEFAULT_SETTINGS.depth,
      profession: (result.profession as string) ?? DEFAULT_SETTINGS.profession,
      displayMode: (result.displayMode as string) ?? DEFAULT_SETTINGS.displayMode,
    })
  );
});
```

**9. Pass settings in fetch body:**

Update the `fetch(BACKEND_URL, {...})` call to include tone/depth/profession:
```typescript
body: JSON.stringify({
  text: selectedText,
  tone: settings.tone,
  depth: settings.depth,
  profession: settings.profession,
}),
```

**10. After SSE `payload.done` — capture original text and push to undo stack:**

In the `if (payload.done)` block, before the existing `chrome.storage.local.set(...)` call, capture the original text and push to undo stack. The `selectedText` variable from the pre-flight read is the original. The `textNode` is the DOM text node created during streaming.

```typescript
// Push to undo stack BEFORE clearing selectedText in storage
undoStack.push({
  originalText: selectedText,
  simplifiedText: accumulated,
  textNode: textNode,
});
renderButton(); // Update hasUndo to true
```

**11. Display mode routing — popup mode:**

After SSE streaming completes (in `payload.done` handler), check `settings.displayMode`. If `displayMode === 'popup'`, instead of leaving the text node in-place (or in addition), render a FloatingPopup:

```typescript
if (settings.displayMode === 'popup') {
  // Revert the in-place DOM change (restore original, user sees popup instead)
  textNode.textContent = selectedText; // Restore original
  const popupContainer = document.createElement('div');
  popupContainer.id = 'twelvify-popup-root';
  document.body.appendChild(popupContainer);
  const popupRoot = createRoot(popupContainer);
  popupRoot.render(
    createElement(FloatingPopup, {
      simplifiedText: accumulated,
      onClose: () => {
        popupRoot.unmount();
        popupContainer.remove();
      },
    })
  );
}
```

Note: FloatingPopup is created in Plan 05. For now, import it with a conditional guard or add a TODO comment. If FloatingPopup does not yet exist when this plan executes, create a minimal stub at `src/components/FloatingPopup.tsx`:

```typescript
// STUB — replaced in 03-05
export function FloatingPopup({ simplifiedText, onClose }: { simplifiedText: string; onClose: () => void }) {
  return null;
}
```

Keep all existing Phase 2 in-place streaming code intact — it's the default path (displayMode='replace').
  </action>
  <verify>
Run `npx tsc --noEmit` — no errors.
Grep `src/entrypoints/content.ts` for `SIMPLIFY_HOTKEY` — must exist.
Grep `src/entrypoints/content.ts` for `undoStack.push` — must exist.
Grep `src/entrypoints/content.ts` for `chrome.storage.sync.get` — must exist (settings read).
Grep `src/entrypoints/content.ts` for `tone.*depth.*profession` in fetch body — must exist.
Grep `src/entrypoints/content.ts` for `beforeunload` — must exist.
  </verify>
  <done>content.ts passes tone/depth/profession to backend; pushes to undo stack on completion; handleUndo() reverts via undoStack.revertLast(); ESC key triggers handleUndo() when stack non-empty; SIMPLIFY_HOTKEY triggers handleSimplify() with text selected guard; display mode routing implemented; TypeScript compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Wire progressive onboarding prompt rendering into content.ts</name>
  <files>src/entrypoints/content.ts</files>
  <action>
Extend the same `src/entrypoints/content.ts` from Task 1 to add progressive onboarding prompt rendering after simplification completes. This runs AFTER Task 1 is complete — build on top of it.

**New imports at top (add to existing imports):**
```typescript
import { OnboardingPrompt } from '../components/OnboardingPrompt';
import { getNextOnboardingPrompt } from '../utils/onboarding';
```

If `OnboardingPrompt` does not yet exist (Plan 05 runs in parallel), create a stub at `src/components/OnboardingPrompt.tsx`:
```typescript
// STUB — replaced in 03-05
export function OnboardingPrompt(_props: {
  prompt: { id: string; title: string; description: string; triggerAt: number };
  onDismiss: () => void;
  onSelect?: (value: string) => void;
}) {
  return null;
}
```

If `getNextOnboardingPrompt` does not yet exist (Plan 05 runs in parallel), create a stub at `src/utils/onboarding.ts`:
```typescript
// STUB — replaced in 03-05
export interface OnboardingPromptDef { id: string; title: string; description: string; triggerAt: number; }
export function getNextOnboardingPrompt(_count: number, _dismissed: string[]): OnboardingPromptDef | null { return null; }
```

**Add onboarding render helper inside `main()` (add after `handleUndo()`):**

```typescript
function renderOnboardingPromptIfNeeded(belowSpan: HTMLElement): void {
  chrome.storage.sync.get(
    ['simplifyCount', 'dismissedOnboardingPrompts'],
    (result) => {
      const count = (result.simplifyCount as number) ?? 0;
      const dismissed = (result.dismissedOnboardingPrompts as string[]) ?? [];
      const prompt = getNextOnboardingPrompt(count, dismissed);
      if (!prompt) return;

      // Create a container div inserted after the simplified text span
      const promptContainer = document.createElement('div');
      promptContainer.id = 'twelvify-onboarding-prompt';
      belowSpan.insertAdjacentElement('afterend', promptContainer);

      const promptRoot = createRoot(promptContainer);

      function dismiss() {
        // Mark prompt as dismissed forever in chrome.storage.sync
        const updated = [...dismissed, prompt!.id];
        chrome.storage.sync.set({ dismissedOnboardingPrompts: updated });
        promptRoot.unmount();
        promptContainer.remove();
      }

      function handleSelect(value: string) {
        // Save the selected preference to chrome.storage.sync
        // Map prompt.id to storage key (tone/depth/profession)
        chrome.storage.sync.set({ [prompt!.id]: value });
        dismiss();
      }

      promptRoot.render(
        createElement(OnboardingPrompt, {
          prompt,
          onDismiss: dismiss,
          onSelect: handleSelect,
        })
      );
    }
  );
}
```

Note: `simplifyCount` in chrome.storage.sync is SEPARATE from `simplifyCount` in chrome.storage.local (which tracks the count used for rate limiting). The sync version tracks the lifetime total for onboarding triggers. After payload.done in handleSimplify(), increment the sync simplifyCount:

```typescript
// Inside payload.done handler, after undoStack.push():
chrome.storage.sync.get(['simplifyCount'], (result) => {
  const newCount = ((result.simplifyCount as number) ?? 0) + 1;
  chrome.storage.sync.set({ simplifyCount: newCount });
  // Check if onboarding prompt should show
  renderOnboardingPromptIfNeeded(span); // span = the highlight span created after streaming
});
```

The `span` variable is the `<span data-twelvify-simplified="true">` created in the highlight-fade section of the existing Phase 2 code. Pass it as the reference element for prompt placement.
  </action>
  <verify>
Run `npx tsc --noEmit` — no errors.
Grep `src/entrypoints/content.ts` for `getNextOnboardingPrompt` — must exist.
Grep `src/entrypoints/content.ts` for `renderOnboardingPromptIfNeeded` — must exist.
Grep `src/entrypoints/content.ts` for `dismissedOnboardingPrompts` — must exist.
  </verify>
  <done>content.ts calls renderOnboardingPromptIfNeeded after each simplification; onboarding prompt appears inline after simplified text; dismiss writes to dismissedOnboardingPrompts in chrome.storage.sync; select writes preference value to chrome.storage.sync; TypeScript compiles cleanly.</done>
</task>

</tasks>

<verification>
Run `npx tsc --noEmit` — zero errors.
Run `npm run build` (if available) — no build errors.
Verify content.ts has all integration points: SIMPLIFY_HOTKEY handler, undoStack.push, handleUndo, ESC listener, chrome.storage.sync.get for settings, getNextOnboardingPrompt, renderOnboardingPromptIfNeeded, dismissedOnboardingPrompts.
</verification>

<success_criteria>
- content.ts reads tone/depth/profession from chrome.storage.sync before each request
- Fetch body includes tone, depth, profession fields
- After simplification: undoStack.push called with originalText + textNode reference
- ESC key: undoStack.revertLast() called when stack non-empty
- SIMPLIFY_HOTKEY message handled — triggers handleSimplify() only with text selected
- Display mode popup path implemented (renders FloatingPopup stub or real component)
- Undo stack cleared on beforeunload
- renderOnboardingPromptIfNeeded called after payload.done; onboarding prompt shown inline
- dismissedOnboardingPrompts respected — dismissed prompts never reappear
- All Phase 2 behavior preserved (SSE streaming, error handling, rate limiting)
- TypeScript compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/03-personalization-ux-polish/03-04-SUMMARY.md` following the summary template.
</output>
