---
phase: 06-playground-interactivity
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - landing/src/components/Playground.tsx
autonomous: true
requirements: [SECT-03, INTX-01, INTX-04, INTX-05]

must_haves:
  truths:
    - "Playground section renders with the exact heading 'Is this even English?', sample text with colored word highlights, and a 'FIX THIS MESS' button"
    - "Clicking the button triggers a fetch to /api/playground, receives SSE chunks, and replaces the sample text character-by-character with a typing animation (30-50ms per char)"
    - "A blinking cursor appears during typing and fades away after completion"
    - "After a successful run, the button is disabled and its label changes to 'FIXED!'"
    - "On 429 rate-limit response, a playful toast notification slides in above the section and auto-dismisses after 5 seconds"
    - "On mid-stream AI error, whatever was typed so far is preserved and a toast notification slides in"
    - "The COMPLEX ORIGINAL / SIMPLIFIED VERSION legend updates after the demo completes"
  artifacts:
    - path: "landing/src/components/Playground.tsx"
      provides: "Playground section component with full interactive demo logic"
      min_lines: 120
  key_links:
    - from: "landing/src/components/Playground.tsx"
      to: "/api/playground"
      via: "fetch POST + ReadableStream SSE parsing"
      pattern: "fetch.*api/playground"
    - from: "landing/src/components/Playground.tsx"
      to: "useState(disabled)"
      via: "setDisabled(true) after done:true SSE event"
      pattern: "setDisabled\\(true\\)"
---

<objective>
Build the Playground React component — the live AI demo section of the landing page.

Purpose: Visitors see a confusing sentence with highlighted complex words, click "FIX THIS MESS", and watch the text get replaced character-by-character via a typing animation as the AI simplifies it. One-shot per page load. Friendly error handling for rate limits.

Output: `landing/src/components/Playground.tsx` — standalone, self-contained component ready to be imported into App.tsx in Plan 03.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/06-playground-interactivity/06-CONTEXT.md
@landing/src/App.tsx
@landing/src/components/Hero.tsx
@landing/src/index.css
@landing/code.html
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Playground component with typing animation, one-shot lock, and error toast</name>
  <files>landing/src/components/Playground.tsx</files>
  <action>
Create `landing/src/components/Playground.tsx`. This is a self-contained React component. No external libraries needed — use React hooks only (`useState`, `useRef`, `useCallback`).

## Visual structure (from code.html lines 164-200 and CONTEXT.md)

Match the existing design. The section markup:
```
<section id="try-it" className="py-32 bg-slate-100">
  <div className="max-w-4xl mx-auto px-6">
    <div className="zine-box bg-white p-12 relative overflow-hidden">
      {/* Toast notification — rendered here, floats above */}
      {/* Header row */}
      <div className="flex flex-col md:flex-row md:items-end justify-between gap-8 mb-12">
        <div className="relative">
          <h2 className="text-4xl mb-4 -rotate-3">Is this even English?</h2>
          <p className="font-punk text-slate-500 italic uppercase">Click the button and watch the magic happen.</p>
        </div>
        {/* FIX THIS MESS button */}
      </div>
      {/* Text display area */}
      {/* Legend */}
    </div>
  </div>
</section>
```

## State

```ts
const SAMPLE_TEXT = "The superfluous utilization of sesquipedalian verbiage inevitably precipitates a profound state of intellectual vertigo for the uninitiated observer.";

const [phase, setPhase] = useState<'idle' | 'loading' | 'typing' | 'done'>('idle');
const [displayText, setDisplayText] = useState('');
const [disabled, setDisabled] = useState(false);
const [toast, setToast] = useState<{ message: string; visible: boolean }>({ message: '', visible: false });
const [showCursor, setShowCursor] = useState(false);
```

## Text display area

In `idle` phase: render the original styled HTML with highlighted words (matching code.html exactly):
```tsx
<p className="text-2xl lg:text-3xl font-punk leading-loose text-slate-800">
  The <span className="bg-primary/20 px-1 border-b-4 border-primary">superfluous</span> utilization of{' '}
  <span className="bg-primary/20 px-1 border-b-4 border-primary">sesquipedalian</span> verbiage inevitably precipitates a profound state of{' '}
  <span className="bg-primary/20 px-1 border-b-4 border-primary">intellectual vertigo</span> for the uninitiated observer.
</p>
```

In `loading`, `typing`, and `done` phases: render `displayText` as plain text (no highlight spans). When `showCursor` is true, append a blinking cursor inline — a `<span>` with class `animate-pulse` containing `|`.

## Button

```tsx
<button
  onClick={handleClick}
  disabled={disabled || phase === 'loading' || phase === 'typing'}
  className={`... ${disabled ? 'bg-slate-400 cursor-not-allowed rotate-0' : 'bg-primary hover:bg-slate-900 rotate-2'} border-2 border-slate-900 px-8 py-4 font-display text-xl shadow-[4px_4px_0px_0px_rgba(0,0,0,1)] transition-colors text-white`}
>
  <span className="material-symbols-outlined align-middle mr-2">
    {phase === 'loading' ? 'hourglass_empty' : 'auto_fix_high'}
  </span>
  {phase === 'loading' ? 'FIXING...' : phase === 'done' || disabled ? 'FIXED!' : 'FIX THIS MESS'}
</button>
```

## handleClick logic

```ts
async function handleClick() {
  setPhase('loading');
  setDisplayText('');
  setShowCursor(true);

  try {
    const res = await fetch('/api/playground', { method: 'POST' });

    if (res.status === 429) {
      const data = await res.json();
      showToast(data.message || "Whoa, slow down! The AI needs a breather.");
      setPhase('idle');
      setShowCursor(false);
      return;
    }

    if (!res.ok) {
      showToast("Something went sideways. Give it another shot.");
      setPhase('idle');
      setShowCursor(false);
      return;
    }

    // SSE stream parsing
    setPhase('typing');
    const reader = res.body!.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    let accumulated = '';

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');
      buffer = lines.pop() ?? '';

      for (const line of lines) {
        if (!line.startsWith('data: ')) continue;
        const json = JSON.parse(line.slice(6));

        if (json.error) {
          // Mid-stream error — preserve what was typed
          showToast(json.message || "Something went wrong mid-stream.");
          setShowCursor(false);
          setPhase('done');
          setDisabled(true);
          return;
        }

        if (json.done) {
          // Typing complete — blink cursor 3 times then fade
          setTimeout(() => setShowCursor(false), 1200);
          setPhase('done');
          setDisabled(true);
          return;
        }

        if (json.chunk) {
          // Typing animation: add chars one by one at 30-50ms per char
          for (const char of json.chunk) {
            accumulated += char;
            const snapshot = accumulated;
            await new Promise<void>(resolve =>
              setTimeout(() => {
                setDisplayText(snapshot);
                resolve();
              }, 35)
            );
          }
        }
      }
    }
  } catch {
    showToast("Network hiccup. Check your connection and try again.");
    setPhase('idle');
    setShowCursor(false);
  }
}
```

## showToast helper

```ts
function showToast(message: string) {
  setToast({ message, visible: true });
  setTimeout(() => setToast(t => ({ ...t, visible: false })), 5000);
}
```

## Toast component (rendered inside zine-box, above header row)

```tsx
{toast.visible && (
  <div className="absolute top-0 left-0 right-0 bg-slate-900 text-white font-punk px-6 py-4 text-sm flex items-center justify-between z-10 border-b-4 border-primary animate-slide-down">
    <span>{toast.message}</span>
    <button onClick={() => setToast(t => ({ ...t, visible: false }))} className="ml-4 text-slate-400 hover:text-white">✕</button>
  </div>
)}
```

For `animate-slide-down`, use a simple Tailwind `transition-all` approach or just render/unrender via the `visible` flag — no custom keyframe needed since the zine-box has `overflow-hidden` which clips the appearance. Keep it simple.

## Legend (bottom of zine-box)

```tsx
<div className="mt-12 flex flex-wrap items-center justify-center gap-10 font-punk font-bold uppercase text-sm">
  <div className={`flex items-center gap-3 border-2 px-4 py-1 rotate-[-2deg] ${phase === 'done' ? 'line-through text-slate-300 border-slate-200' : 'text-slate-400 border-slate-200'}`}>
    <div className="size-3 bg-slate-300" /> COMPLEX ORIGINAL
  </div>
  <span className="material-symbols-outlined text-slate-300 scale-150">trending_flat</span>
  <div className={`flex items-center gap-3 border-2 px-4 py-1 rotate-[2deg] ${phase === 'done' ? 'text-primary border-primary font-black' : 'text-primary border-primary'}`}>
    <div className="size-3 bg-primary" /> SIMPLIFIED VERSION
  </div>
</div>
```

## Text area container

```tsx
<div className="p-10 border-4 border-dashed border-slate-300 bg-background-light rotate-1 min-h-[120px]">
  {phase === 'idle' ? (
    <p className="text-2xl lg:text-3xl font-punk leading-loose text-slate-800">
      {/* Original with highlights */}
    </p>
  ) : (
    <p className="text-2xl lg:text-3xl font-punk leading-loose text-slate-800">
      {displayText}
      {showCursor && <span className="animate-pulse ml-0.5 text-primary">|</span>}
    </p>
  )}
</div>
```

## Important implementation notes

- The `await new Promise` typing loop inside an async function with `setDisplayText` works in React 19 — no batching issues for this pattern
- `fetch('/api/playground', { method: 'POST' })` — no Content-Type header needed since we send no body
- Export default: `export default function Playground() { ... }`
- The component does NOT need to import anything from constants.ts
- No `useEffect` needed — all logic triggered by button click
  </action>
  <verify>
    Run: `cd /Users/brunocampos/Twelvify/landing && npx tsc --noEmit 2>&1`
    Must exit with 0 TypeScript errors.
    Run: `grep -n "api/playground" /Users/brunocampos/Twelvify/landing/src/components/Playground.tsx`
    Must show the fetch call to /api/playground.
    Run: `grep -n "setDisabled(true)" /Users/brunocampos/Twelvify/landing/src/components/Playground.tsx`
    Must appear in the done/success path.
  </verify>
  <done>
    `landing/src/components/Playground.tsx` exists and exports a default React component.
    TypeScript compiles clean with no errors.
    Component contains: section#try-it, h2 "Is this even English?", FIX THIS MESS button, SSE fetch logic, one-shot disable, toast error handling.
  </done>
</task>

</tasks>

<verification>
- `landing/src/components/Playground.tsx` exists
- `cd /Users/brunocampos/Twelvify/landing && npx tsc --noEmit` exits 0
- Component renders section with id="try-it"
- fetch targets '/api/playground' with POST method
- Button becomes disabled after successful `done: true` SSE event
- Toast appears on 429 and auto-dismisses after 5s
- No external npm packages added — pure React hooks
</verification>

<success_criteria>
- Playground component exists and compiles without TypeScript errors
- It fetches /api/playground (not /api/simplify)
- Typing animation characters appear at 35ms intervals via per-char setTimeout loop
- Button disabled + label "FIXED!" after first success
- Toast error handling covers: 429, non-ok HTTP, mid-stream error, network failure
- Original text highlights rendered correctly in idle phase
- Legend updates visually after demo completes
</success_criteria>

<output>
After completion, create `.planning/phases/06-playground-interactivity/06-02-SUMMARY.md`
</output>
